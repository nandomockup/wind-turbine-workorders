name: Wind Turbine Work Orders - Auto Documentation

on:
  push:
    branches: [ main, master, develop ]
    paths:
      - '**.cs'
      - '**.csproj'
  pull_request:
    branches: [ main, master ]

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 2
    
    - name: Get changed files
      id: changed-files
      run: |
        git diff --name-only HEAD^ HEAD > changed_files.txt
        echo "Changed files:"
        cat changed_files.txt
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-east-1
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        pip install boto3
    
    - name: Generate documentation with AWS Bedrock
      run: |
        python3 << 'EOF'
        import boto3
        import json
        import os
        from datetime import datetime
        
        # Initialize Bedrock client
        bedrock = boto3.client('bedrock-runtime', region_name='us-east-1')
        
        # Read changed files
        with open('changed_files.txt', 'r') as f:
            changed_files = [line.strip() for line in f if line.strip().endswith('.cs')]
        
        if not changed_files:
            print("No C# files changed, skipping documentation generation")
            exit(0)
        
        # Read content of changed files
        files_content = {}
        for file_path in changed_files:
            if os.path.exists(file_path):
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        files_content[file_path] = f.read()
                except Exception as e:
                    print(f"Error reading {file_path}: {e}")
        
        if not files_content:
            print("No valid file content to process")
            exit(0)
        
        # Prepare enhanced prompt for Wind Turbine Work Orders system
        prompt_parts = [
            "You are analyzing a Wind Turbine Work Orders Management System built with ASP.NET Core.",
            "",
            "Generate comprehensive, professional API documentation in Markdown format for the following changed files:",
            ""
        ]
        
        for file_path, content in files_content.items():
            # Limit to 4000 chars per file to manage token usage
            truncated_content = content[:4000]
            if len(content) > 4000:
                truncated_content += "\n... [truncated]"
            prompt_parts.append(f"## File: {file_path}")
            prompt_parts.append(f"```csharp\n{truncated_content}\n```")
            prompt_parts.append("")
        
        prompt_parts.extend([
            "Generate documentation with these sections:",
            "",
            "# Wind Turbine Work Orders API - Change Log",
            "",
            "## Overview",
            "- Summarize what changed and the business impact",
            "- Explain how this affects work order management",
            "",
            "## API Endpoints",
            "For each endpoint, document:",
            "- **HTTP Method & Route**",
            "- **Purpose** - What does this endpoint do in the work order workflow?",
            "- **Parameters** - Query params, route params, request body",
            "- **Request Example** - JSON payload",
            "- **Response Example** - Success response with JSON",
            "- **Error Responses** - Common errors (400, 401, 404, 500)",
            "- **Authorization** - Required roles or permissions",
            "",
            "## Data Models",
            "- Document any DTOs, entities, or view models",
            "- Show property types and validation rules",
            "- Explain relationships (e.g., WorkOrder â†’ Turbine)",
            "",
            "## Business Logic",
            "- Key business rules implemented",
            "- Workflows (e.g., work order lifecycle: Created â†’ Assigned â†’ In Progress â†’ Completed)",
            "- Validation logic",
            "",
            "## Database Changes",
            "- Any new tables, columns, or migrations",
            "- Relationships and foreign keys",
            "",
            "## Usage Examples",
            "Provide code snippets showing:",
            "- How to create a work order",
            "- How to update turbine status",
            "- How to query work orders",
            "",
            "---",
            "**Format:** Use proper Markdown with headers, code blocks, and tables.",
            "**Style:** Professional, clear, and developer-friendly."
        ])
        
        prompt = "\n".join(prompt_parts)
        
        # Call Bedrock with Claude
        request_body = {
            "anthropic_version": "bedrock-2023-05-31",
            "max_tokens": 4096,
            "temperature": 0.3,
            "messages": [
                {
                    "role": "user",
                    "content": prompt
                }
            ]
        }
        
        try:
            response = bedrock.invoke_model(
                modelId='us.anthropic.claude-3-5-sonnet-20241022-v2:0',
                body=json.dumps(request_body)
            )
            
            response_body = json.loads(response['body'].read())
            documentation = response_body['content'][0]['text']
            
            # Create docs directory
            os.makedirs('docs', exist_ok=True)
            
            # Generate timestamp
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')
            
            # Generate changelog entry
            changelog_parts = [
                "---",
                "",
                f"## Update: {timestamp}",
                "",
                "**Changed Files:**"
            ]
            
            for f in changed_files:
                changelog_parts.append(f"- `{f}`")
            
            changelog_parts.append("")
            changelog_parts.append(documentation)
            changelog_parts.append("")
            
            changelog_entry = "\n".join(changelog_parts)
            
            # Update or create index
            index_path = 'docs/index.md'
            if os.path.exists(index_path):
                with open(index_path, 'r', encoding='utf-8') as f:
                    existing_content = f.read()
                
                # Insert new changelog at the top
                header = "# Wind Turbine Work Orders API Documentation\n\n**Last Updated:** " + timestamp + "\n\n"
                if existing_content.startswith("# Wind Turbine Work Orders"):
                    # Find the end of the header section
                    parts = existing_content.split("---", 1)
                    if len(parts) > 1:
                        new_content = parts[0] + changelog_entry + "\n" + parts[1]
                    else:
                        new_content = header + changelog_entry + "\n\n" + existing_content
                else:
                    new_content = header + changelog_entry + "\n\n" + existing_content
            else:
                header_parts = [
                    "# Wind Turbine Work Orders API Documentation",
                    "",
                    f"**Repository:** [wind-turbine-workorders](https://github.com/nandomockup/wind-turbine-workorders)",
                    f"**Last Updated:** {timestamp}",
                    "",
                    "> This documentation is automatically generated using AI whenever the API code changes.",
                    ""
                ]
                new_content = "\n".join(header_parts) + "\n" + changelog_entry
            
            with open(index_path, 'w', encoding='utf-8') as f:
                f.write(new_content)
            
            print("Documentation generated successfully!")
            print(f"Updated: docs/index.md")
            
        except Exception as e:
            print(f"Error calling Bedrock: {e}")
            import traceback
            traceback.print_exc()
            raise
        
        EOF
    
    - name: Setup GitHub Pages config
      run: |
        cd docs
        cat > _config.yml << 'EOF'
        theme: jekyll-theme-slate
        title: Wind Turbine Work Orders API
        description: Auto-generated API documentation
        show_downloads: true
        EOF
    
    - name: Commit documentation
      run: |
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        git add docs/
        git diff --staged --quiet || git commit -m "ðŸ“š Auto-generated API documentation [skip ci]"
    
    - name: Push changes
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        branch: ${{ github.ref }}
    
    - name: Deploy to GitHub Pages
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./docs
        publish_branch: gh-pages
